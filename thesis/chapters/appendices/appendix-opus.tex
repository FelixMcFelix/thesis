\chapter{Opus VoIP Traffic Capture and Generation}\label{adx:opus-traffic}
To provide a realistic model of normal congestion-unaware traffic to properly evaluate the work in \cref{chap:ddos-rl}, I passively measured \gls{acr:voip} traffic generated by users of the Discord~\parencite{discord} online chat service to acquire reasonable traces and then generate appropriately similar traffic.
Discord allows text, voice and streaming video conversation between users---the latter two allow real-time communication over \gls{acr:udp}.
I am interested here in voice, which is effectively \gls{acr:cbr} and congestion-unaware, but is easily accessible by bot users (unlike video).

\gls{acr:voip} application traffic has interesting characteristics.
Client$\rightarrow$server flows contain an audio stream mixed with in-band and out-of-band control traffic.
Audio streams are encoded at a target bitrate (e.g., \qty{96}{\kilo\bit\per\second}) and divided into individual packets to provide continuous delivery of traffic---these are usually relatively large ($\sim$\qty{20}{\milli\second}) to reduce packet transport overhead, but small enough to minimise the impact of packet losses.
Due to this real-time requirement, audio packet arrivals and transmissions are then highly periodic.
There are other interesting dynamics, aside from the trivial observation that flows won't react substantially to lost packets.
In Discord's architecture (and I suspect in the general case nowadays to achieve better and more consistent \gls{acr:qoe}), \emph{all} packets are sent to a single \gls{acr:turn} server~\parencite{rfc8656}, which relays them between users to ensure connectivity (as opposed to, say, peer-to-peer session links).
This causes inbound \gls{acr:rtp} packets to fan out to all other participants in a call, leading to a moderate amplification factor.

%?? Also interesting per-server dynamics. TURN servers, fan in/out -- similarity to attacks in some respects? (i.e., \gls{acr:turn}~\parencite{rfc8656} server amplifies.)

Sadly, it is insufficient to just encode arbitrary audio at a voice channel's supposed bitrate and then divide that into fixed-size packets.
The exact size of each packet depends on the carried content, but tends in the long term towards \gls{acr:cbr} for speech or music.
Silent frames are, of course, the smallest to encode (e.g., \qty{5}{\byte} for the Opus codec).
Smaller signal-dependent variations aside, since users tend to converse with each other they typically speak in bursts of various lengths rather than continuously, and can cease sending packets during these times to save bandwidth.
Obviously, this leads to burstier traffic than simply taking the expected link occupation over each user's stream.
Moreover, the duration of individual voice sessions and number of recipients also play a part in how traffic is fanned out at the \gls{acr:turn} server, and to whom.

From the above, we have quite a few factors which affect both client$\rightarrow$server and server$\rightarrow$client behaviour.
At the time I was designing the evaluation for \cref{chap:ddos-rl}, I couldn't find conclusive studies on \gls{acr:voip} traffic which would be at all useful in modelling these sorts of dynamics---and still haven't quite seen any works which fill the same niche.
This appendix describes my methodology for capturing and generating somewhat simplified variants of these flows---i.e., discounting control traffic and shared sessions to minimise out-of-band coordination.

%?? WHy all this? Couldn't find a good generator.
%
%?? Problem description: Discord \gls{acr:voip} flows are \gls{acr:cbr} while speaking (bitrate is chosen per voice channel, not adaptive in this circumstance). 

%?? Highly periodic

\section{Voice session behaviour}
Discord's \gls{acr:voip} sessions target a preset bitrate per voice channel chosen by that server's administrators---\qtyrange{8}{96}{\kilo\bit\per\second} on free servers\sidenote{\qtylist{128;256;384}{\kilo\bit\per\second} are offered to paying users. This only affects client behaviour: the \gls{acr:turn} server is not stringent enough to block or re-encode voice data sent by bots or custom clients.}, defaulting to \qty{64}{\kilo\bit\per\second}.
Clients connect by requesting session IDs and keys over the main WebSocket \gls{acr:api}, which are used to open another WebSocket session for voice control traffic.
This includes negotiating the cryptographic tag scheme, and receiving an \gls{acr:rtp} \gls{acr:ssrc}, URL and port for a \gls{acr:udp} \gls{acr:turn} server.
Connection then proceeds to make use of WebRTC (web browser users) or vanilla \gls{acr:rtp}: in the latter case, explicit \gls{acr:nat} hole punching is performed.
This WebSocket session is maintained over the call's lifetime to provide information about other users and exchange periodic heartbeat messages.

% \gls{acr:voip} flows are \gls{acr:cbr} while speaking (bitrate is chosen per voice channel, not adaptive in this circumstance). 

Audio is encoded using the Opus codec, split into \qty{20}{\milli\second} \gls{acr:rtp}~\parencite{rfc3550} packets at the session's target bitrate.
In practice, these include \gls{acr:rtp} extensions to denote (among other functions) hosts' \gls{acr:ntp} timestamps and per-packet loudness.
Clients additionally send random \qty{4}{\byte} \gls{acr:udp} keepalive values to the \gls{acr:turn} server every \qty{5}{\second}, along with \gls{acr:rtcp} reports generated at the intervals defined in the specification.
\gls{acr:rtp} and \gls{acr:rtcp} are multiplexed over the same socket~\parencite{rfc5761}, while payloads are encrypted using XSalsa20-Poly1305~\parencite{xsalsa20,rfc8439}.
The method of doing so is not quite adherent to the Secure \gls{acr:rtp} specification~\parencite{rfc3711}---encryption and placement of the message authentication code occur using fixed offsets in the parent \gls{acr:udp} packet.
When users cease speaking, they will send up to 5 silent frames of audio before they stop transmitting packets (resuming on the next significant audio data).
Encrypted, multiplexed \gls{acr:rtp} and \gls{acr:rtcp} packets from other users are received on the socket used for earlier \gls{acr:nat} hole-punching.

%To (I assume) achieve better and more consistent \gls{acr:qoe} than peer-to-peer transmission, all voice and video traffic is sent to a central \gls{acr:turn}~\parencite{rfc8656} server which
%
%?? turn does encrypt/re-encrypt as MAC mode is user-negotiated. 

\section{Capture and storage}
%?? Emphasise anonymity, nature of servers, consent for all users.
Traces were captured using two strategies by a voice bot, \emph{Felyne}, which probabilistically played sounds and music from the \emph{Monster Hunter} series of games following simple \glspl{acr:fsm}.
In both cases, consent was given by captured users in a limited set of close-knit servers (general purpose, role-playing, games-focussed) and all traces are fully anonymised to comply with GDPR.
The first strategy (\emph{Version \RN{1}}) was developed and used for \cref{chap:ddos-rl}, while the second (\emph{Version \RN{2}}) is used in ongoing measurement.

\paragraph{Version \RN{1}}
Traces are captured on a per-user or -\gls{acr:ssrc} basis, to make generation simpler than tracking all call dynamics.
During a call, for every packet received from each \gls{acr:ssrc} I record its \gls{acr:rtp} timestamp\sidenote{This is in sample units of the source audio data, }, sequence number, and Opus payload size in bytes.
Payload sizes do not include \gls{acr:rtp} extensions or additional bytes required to store message authentication codes or cryptographic nonces.
\gls{acr:rtcp} packets and \gls{acr:rtp} extensions are discarded.

When a user disconnects, or the next packet would cause the timestamp to overflow relative to its first seen value ($\sim$\qty{1491.3}{\minute} for \mintinline{rust}|u32|s at \num{960} samples per packet), the session is finalised and stored.
To finalise a trace, packet metadata is sorted by its timestamp.
I then replace each packet with its payload size, insert `Missing' markers where expected sequence numbers are not observed, and insert `Silent' duration markers for valid packet gaps longer than \qty{20}{\milli\second}.

\paragraph{Version \RN{2}}
Traces are captured on a per-call basis, and instead record all \gls{acr:rtp} and \gls{acr:rtcp} packet arrivals as a single stream of events timestamped using the system clock.
This model is designed to capture the interactions between user voice sessions, rather than simply speaking-silent burst modelling.
WebSocket events and timestamps are stored and used to detect user arrivals, departures, and associate multiple \glspl{acr:ssrc} to individual users in the event of reconnections.
For each arrived \gls{acr:rtp} packet, I capture its arrival time, \gls{acr:ssrc}, sequence number, \gls{acr:rtp} timestamp, extension data, and the Opus payload size.
Sequence numbers and \gls{acr:rtp} timestamps are reduced such that every flow's counters begin from 0.

For processing, user IDs and \glspl{acr:ssrc} are converted into opaque identifiers (i.e., the first seen \gls{acr:ssrc} is `user 0', and so on).
\glspl{acr:ssrc} and IDs in all observed WebSocket, \gls{acr:rtp}, and \gls{acr:rtcp} packets are replaced with these identifiers.
Felyne tracks users who have opted in and out according to per-server configuration (using opt-in `roles' and explicit global opt-outs): any \gls{acr:rtp}, \gls{acr:rtcp}, or speech events from such users are filtered out.
Join and disconnect events from these users are not removed, so as to correctly preserve fan-out behaviour of the \gls{acr:turn} server for this call
A list of all opt-out IDs is stored to make it clear how accurate a trace is (e.g., making it clear whether packet events are present for 6/8 users over the duration).
\gls{acr:rtp} extensions are kept intact if the type is known to include no personal data (i.e., loudness indicators)---otherwise, extension payloads are zeroed while their types are kept, including those encoded past the one- and two-byte header extensions~\parencite{rfc8285}.
\gls{acr:rtcp} packets are sanitised such that \gls{acr:ntp} timestamps begin at zero, and \glspl{acr:ssrc} are anonymised as above.

\section{Traffic generation}
Currently, \gls{acr:rtp} traffic generation is only supported using \emph{Version \RN{1}} traces.
%\paragraph{Version \RN{1}}
I designed a client and server program for this purpose, implementing a simplified form of the session behaviour described above---i.e., without WebSocket control traffic, sender-to-sender coordination of speaking periods, or \gls{acr:rtcp} packets.

The server program receives \gls{acr:udp} traffic on a given port, where it reflects keepalive packets back to their sender and attempts to forward \gls{acr:rtp} packets to the other recipients in a `room'.
Inbound flow 5-tuples plus \glspl{acr:ssrc} are assigned to these rooms: each is given a uniformly random capacity from \numrange{2}{8} participants, and one room-in-progress is held at a time.

Clients randomly draw (without replacement) from the set of all traces, generating \gls{acr:rtp} packets every \qty{20}{\milli\second} during speaking phases.
Source \gls{acr:ip} addresses, ports, and \glspl{acr:ssrc} are randomly generated, and packet bodies are filled with pre-generated random bytes.
Sent packets include enough extra bytes on top of the payload to store the Poly1305 message authentication code (\qty{16}{\byte}).
Additionally, hosts punctuate these \gls{acr:rtp} frames with a \qty{4}{\byte} keepalive every \qty{5}{\second}.
Due to the lengthy talk and silence bursts introduced by users in tabletop role-playing servers, silent periods are trimmed to a maximum \qty{5}{\second}.
Missed packets are handled by calculating an exponentially-weighted moving average over the observed payload sizes.
This process continues until the current trace completes \emph{and} the flow has exceeded a user-specified minimum time, at which point a new session is begun.
Individual client flows were found to occupy an expected \qty{52.4}{\kilo\bit\per\second} upstream bandwidth.

%We trim these silent periods to a maximum \qty{5}{\second} due to the lengthy talk/silence bursts introduced by users in RPG servers, and estimate the size of missed packets by taking an exponentially-weighted moving average over known sizes.
%Hosts punctuate audio frames with a 4-byte keepalive every \qty{5}{\second}.
%All traffic passes over a central server which groups hosts into rooms, and is forwarded to other participants; we do not replicate pre-call Websocket traffic which would be used for authentication.
%There is no peer-to-peer traffic---the server acts as a \gls{acr:turn} relay for all hosts.
%%?? Reflective factor among \emph{authenticated hosts}.
%Each flow occupies an expected \qty{52.4}{\kilo\bit\per\second} upstream bandwidth.
%To match the target upload rate assigned to a host, each runs enough individual sessions to meet the target data rate.
%
%?? Expand??

%\paragraph{Version \RN{2}} BBB
%?? Not actually a thing yet

